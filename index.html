<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Island Council — Solo Prototype</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin:0; background:#0b1020; color:#e7eaf3; }
    .wrap { max-width: 1050px; margin: 0 auto; padding: 20px; }
    h1 { margin: 0 0 8px; font-size: 22px; }
    .sub { opacity:.8; margin:0 0 14px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 920px){ .grid{ grid-template-columns:1fr; } }
    .card { background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.10); border-radius: 14px; padding: 14px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .row > * { flex: 1; }
    label { display:block; font-size: 13px; opacity:.9; margin: 8px 0 6px; }
    input, select, textarea, button {
      width: 100%; box-sizing: border-box;
      border-radius: 10px; border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25); color: #e7eaf3;
      padding: 10px 12px; font-size: 14px;
    }
    button { cursor:pointer; background: rgba(255,255,255,.10); }
    button.primary { background: rgba(80,180,255,.22); border-color: rgba(80,180,255,.35); }
    button.danger { background: rgba(255,90,120,.18); border-color: rgba(255,90,120,.30); }
    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border-radius: 999px;
      background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); font-size: 13px; }
    .muted { opacity:.75; font-size: 13px; }
    .hr { height:1px; background: rgba(255,255,255,.10); margin: 12px 0; }
    table { width:100%; border-collapse: collapse; font-size: 13px; }
    th, td { text-align:left; padding: 8px 6px; border-bottom: 1px solid rgba(255,255,255,.10); vertical-align: top; }
    th { opacity:.8; font-weight: 600; }
    .tag { display:inline-flex; padding: 2px 8px; border-radius: 999px; font-size: 12px;
      background: rgba(80,180,255,.18); border: 1px solid rgba(80,180,255,.28); }
    .tag2 { display:inline-flex; padding: 2px 8px; border-radius: 999px; font-size: 12px;
      background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .log { max-height: 320px; overflow:auto; border-radius: 12px; border: 1px solid rgba(255,255,255,.10); }
    .log .line { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,.08); }
    .log .line:last-child { border-bottom: none; }
    .name { font-weight: 700; }
    .small { font-size: 12px; opacity:.85; }
    .good { color: #a8ffb5; }
    .bad { color: #ff9fb2; }
    .warn { color: #ffd38a; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Island Council — Solo Prototype</h1>
    <p class="sub">
      You play alone. The computer simulates NPCs (dialogue, alliances, votes).
      <span class="pill" id="roundPill">Round: —</span>
      <span class="pill" id="captainPill">Speaker Captain: —</span>
    </p>

    <div class="grid">
      <div class="card">
        <div class="row">
          <button class="primary" id="newGameBtn">New Game</button>
          <button id="nextRoundBtn" class="primary" disabled>Run Next Round</button>
          <button class="danger" id="resetBtn">Reset</button>
        </div>

        <div class="hr"></div>

        <div class="row">
          <span class="pill">Community: <b id="communityScore">—</b>/10</span>
          <span class="pill">Selfish: <b id="selfishScore">—</b>/10</span>
          <span class="pill">Your Health: <b id="yourHealth">—</b>/10</span>
        </div>

        <div class="hr"></div>

        <h3 style="margin:0 0 8px; font-size:15px;">Your Choice (one decision)</h3>
        <div class="muted">
          Each round you choose who receives <b>Water</b>. Only one person can receive it.
          The Water recipient becomes <b>Speaker Captain</b> next round (controls speaking order).
        </div>

        <label style="margin-top:10px;">Pick Water recipient</label>
        <select id="waterPick"></select>

        <div class="row" style="margin-top:10px;">
          <button id="confirmPickBtn" class="primary" disabled>Confirm Water Pick</button>
          <button id="autoPickBtn">Suggest Pick</button>
        </div>

        <div class="hr"></div>

        <div class="muted small">
          <b>Stats:</b> Health (0–10), Independence (0–2), Selfish Index (0–2), Alliance Need (0–2), Skill (1 of 4).
          <br/>
          <b>Health tick:</b> Indep 0 = -2, Indep 1 = -1, Indep 2 = 0 each round.
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 8px; font-size:15px;">Characters</h3>
        <div class="muted">No one is eliminated. When Health hits 0, they “collapse” and can’t speak/vote for 1 round.</div>
        <div class="hr"></div>

        <table id="charsTable">
          <thead>
            <tr>
              <th>Name</th>
              <th>Health</th>
              <th>Indep</th>
              <th>Selfish</th>
              <th>Alliance</th>
              <th>Skill</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <h3 style="margin:0 0 8px; font-size:15px;">Round Log</h3>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

  <script>
    // ----------------------------
    // Minimal Solo Game Engine
    // ----------------------------
    const SKILLS = ["Builder", "Medic", "Hunter", "Navigator"];

    const NAMES = ["Jordan","Avery","Sam","Taylor","Casey","Riley","Morgan","Quinn","Cameron","Drew","Alex","Jamie"];

    function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
    function pick(arr){ return arr[Math.floor(Math.random() * arr.length)]; }
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    // Dialogue templates: simple + effective (no external AI).
    const DIALOGUE = {
      2: [ // selfish
        "I’m not giving water away without a return.",
        "We need strength, not sympathy.",
        "If we keep saving the weak, we all go down.",
        "I’m watching who’s useful. That’s the only logic."
      ],
      1: [ // mixed
        "I get both sides—who helps us tomorrow?",
        "I’ll support the choice that improves our odds.",
        "We need a plan, not just feelings.",
        "Convince me this isn’t a mistake."
      ],
      0: [ // community
        "If we ignore the vulnerable, we lose our humanity.",
        "We should protect whoever is in real danger.",
        "Let’s choose what keeps the group together.",
        "Care is strategy. It keeps us alive."
      ]
    };

    const state = {
      started: false,
      round: 0,
      maxRounds: 8,
      community: 6,
      selfish: 4,
      speakerCaptainId: null, // affects speaking order
      chars: [], // includes player + NPCs
      pendingPickId: null,
    };

    // Character model:
    // { id, name, isPlayer, health, indep, selfish, allianceNeed, skill, collapsedUntilRound, allyIdLastRound, helpedLastRoundBy }

    function newChar({name, isPlayer=false}) {
      return {
        id: crypto.randomUUID(),
        name,
        isPlayer,
        health: isPlayer ? 8 : randInt(5, 10),
        indep: isPlayer ? 1 : randInt(0, 2),
        selfish: isPlayer ? 1 : randInt(0, 2),
        allianceNeed: isPlayer ? 1 : randInt(0, 2),
        skill: pick(SKILLS),
        collapsedUntilRound: 0, // if > current round, can't act
        allyIdLastRound: null,
        helpedLastRoundBy: null,
      };
    }

    // UI helpers
    const $ = (id) => document.getElementById(id);

    function logLine(html){
      const log = $("log");
      const div = document.createElement("div");
      div.className = "line";
      div.innerHTML = html;
      log.prepend(div);
    }

    function clearLog(){ $("log").innerHTML = ""; }

    function render() {
      $("roundPill").textContent = state.started ? `Round: ${state.round}/${state.maxRounds}` : "Round: —";
      $("communityScore").textContent = state.started ? state.community : "—";
      $("selfishScore").textContent = state.started ? state.selfish : "—";

      const player = state.chars.find(c => c.isPlayer);
      $("yourHealth").textContent = state.started ? player.health : "—";

      const captainName = state.speakerCaptainId ? state.chars.find(c=>c.id===state.speakerCaptainId)?.name : "—";
      $("captainPill").textContent = `Speaker Captain: ${captainName || "—"}`;

      // Table
      const tbody = $("charsTable").querySelector("tbody");
      tbody.innerHTML = "";
      for (const c of state.chars) {
        const isCollapsed = state.round < c.collapsedUntilRound;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>
            <span class="name">${escapeHtml(c.name)}</span>
            ${c.isPlayer ? ' <span class="tag">You</span>' : ''}
          </td>
          <td>${c.health}</td>
          <td>${c.indep}</td>
          <td>${c.selfish}</td>
          <td>${c.allianceNeed}</td>
          <td><span class="tag2">${escapeHtml(c.skill)}</span></td>
          <td>${isCollapsed ? '<span class="bad">Collapsed</span>' : '<span class="good">Active</span>'}</td>
        `;
        tbody.appendChild(tr);
      }

      // Water pick dropdown
      const sel = $("waterPick");
      sel.innerHTML = "";
      for (const c of state.chars) {
        const isCollapsed = state.round < c.collapsedUntilRound;
        const opt = document.createElement("option");
        opt.value = c.id;
        opt.textContent = `${c.name}${c.isPlayer ? " (You)" : ""}${isCollapsed ? " [Collapsed]" : ""} — H:${c.health} I:${c.indep} S:${c.selfish} Skill:${c.skill}`;
        sel.appendChild(opt);
      }

      $("nextRoundBtn").disabled = !state.started || state.round >= state.maxRounds || isGameOver().over;
      $("confirmPickBtn").disabled = !state.started || state.round === 0 || state.pendingPickId == null || isGameOver().over;
    }

    function escapeHtml(str){
      return String(str).replace(/[&<>"']/g, s => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[s]));
    }

    function isGameOver(){
      if (!state.started) return { over:false, reason:"" };
      const player = state.chars.find(c=>c.isPlayer);
      if (player.health <= 0) return { over:true, reason:"You collapsed (Health reached 0)." };
      if (state.community <= 0) return { over:true, reason:"Community collapsed (Community score reached 0)." };
      if (state.selfish >= 10 && state.community <= 2) return { over:true, reason:"The group fragmented (Selfish dominated)." };
      return { over:false, reason:"" };
    }

    // ----------------------------
    // Core Mechanics
    // ----------------------------

    // Health tick based on independence
    function applyHealthTick(){
      for (const c of state.chars) {
        if (state.round < c.collapsedUntilRound) continue; // already collapsed, skip tick this round
        const loss = (c.indep === 0) ? 2 : (c.indep === 1 ? 1 : 0);
        c.health = clamp(c.health - loss, 0, 10);
        if (c.health === 0) {
          c.collapsedUntilRound = state.round + 1; // can't act next round
        }
      }
    }

    // Choose alliances for NPCs (simple)
    function computeAlliances(){
      // reset
      for (const c of state.chars) if (!c.isPlayer) c.allyIdLastRound = null;

      // Each NPC picks one ally candidate (or null)
      const picks = new Map(); // npcId -> allyId
      const candidates = state.chars.map(c=>c.id);

      for (const npc of state.chars.filter(c=>!c.isPlayer)) {
        if (state.round < npc.collapsedUntilRound) continue;

        // Alliance desire increases when low health or high allianceNeed
        const desire = npc.allianceNeed + (npc.health <= 4 ? 1 : 0);
        if (desire <= 0) continue;

        // Pick ally by "safety + usefulness + similarity"
        let best = null, bestScore = -1e9;
        for (const cid of candidates) {
          if (cid === npc.id) continue;
          const other = state.chars.find(x=>x.id===cid);
          if (state.round < other.collapsedUntilRound) continue;

          let s = 0;
          // usefulness: skills that help group are valued more by community-ish NPCs
          const groupValue = (other.skill === "Medic" ? 2 : (other.skill === "Hunter" ? 2 : 1));
          s += groupValue * (npc.selfish === 0 ? 2 : 1);

          // safety: prefer healthier allies if selfish, prefer vulnerable if community
          s += (npc.selfish === 2 ? other.health : (10 - other.health)) * 0.2;

          // similarity helps alliances form
          s += (other.selfish === npc.selfish ? 1 : 0);
          s += (other.indep === npc.indep ? 0.5 : 0);

          // reciprocity: if other helped them last round, big boost
          s += (npc.helpedLastRoundBy === other.id ? 3 : 0);

          // selfish NPCs avoid empowering "too strong" competitors
          if (npc.selfish === 2 && other.health >= 8) s -= 1;

          if (s > bestScore) { bestScore = s; best = other.id; }
        }
        if (best) picks.set(npc.id, best);
      }

      // Alliances are mutual picks
      const alliances = [];
      for (const [a, b] of picks.entries()) {
        if (picks.get(b) === a) {
          alliances.push([a,b]);
        }
      }
      // Store
      for (const [a,b] of alliances) {
        const A = state.chars.find(x=>x.id===a);
        const B = state.chars.find(x=>x.id===b);
        if (A) A.allyIdLastRound = b;
        if (B) B.allyIdLastRound = a;
      }

      return alliances;
    }

    // NPC dialogue: 1 line each, ordered by Speaker Captain effect
    function npcDialogue(){
      const order = speakingOrderForThisRound();
      for (const cid of order) {
        const c = state.chars.find(x=>x.id===cid);
        if (!c || c.isPlayer) continue;
        if (state.round < c.collapsedUntilRound) {
          logLine(`<span class="name">${escapeHtml(c.name)}</span>: <span class="muted">(...collapsed, no comment)</span>`);
          continue;
        }
        const base = pick(DIALOGUE[c.selfish]);
        const add = dialogueAddon(c);
        logLine(`<span class="name">${escapeHtml(c.name)}</span>: “${escapeHtml(base)}${add}”`);
      }
    }

    function dialogueAddon(c){
      // Add tiny context to make it feel responsive
      if (c.health <= 3) return ` <span class="small warn">(My health is low.)</span>`;
      if (c.allyIdLastRound) return ` <span class="small">(I’m with ${escapeHtml(state.chars.find(x=>x.id===c.allyIdLastRound)?.name || "someone")}.)</span>`;
      return "";
    }

    // Speaker Captain controls speaking order NEXT round; in solo, we simulate order:
    // Captain first, then captain's ally (if any), then others, then the player's line last (you decide).
    function speakingOrderForThisRound(){
      const ids = state.chars.map(c=>c.id);
      const captainId = state.speakerCaptainId;
      if (!captainId) return ids; // round 1: free-for-all

      const captain = state.chars.find(c=>c.id===captainId);
      const ally = captain?.allyIdLastRound || null;

      const rest = ids.filter(id => id !== captainId && id !== ally);
      // Put player near the end to increase "voice pressure"
      const playerId = state.chars.find(c=>c.isPlayer)?.id;
      const restNoPlayer = rest.filter(id => id !== playerId);
      const withPlayerLast = playerId ? [...restNoPlayer, playerId] : restNoPlayer;

      const order = [captainId];
      if (ally) order.push(ally);
      order.push(...withPlayerLast.filter(Boolean));
      return order;
    }

    // NPC voting for water recipient
    function npcVotes(){
      const votes = []; // { voterId, targetId, reason }
      const candidates = state.chars.map(c=>c.id);

      for (const npc of state.chars.filter(c=>!c.isPlayer)) {
        if (state.round < npc.collapsedUntilRound) continue;

        let best = null, bestScore = -1e9, bestReason = "";
        for (const cid of candidates) {
          const target = state.chars.find(x=>x.id===cid);
          if (!target) continue;
          if (state.round < target.collapsedUntilRound) continue; // don't vote for collapsed

          const {score, reason} = scoreVote(npc, target);
          if (score > bestScore) { bestScore = score; best = cid; bestReason = reason; }
        }
        if (best) votes.push({ voterId: npc.id, targetId: best, reason: bestReason });
      }
      return votes;
    }

    function scoreVote(voter, target){
      // Minimal but dynamic scoring
      let score = 0;
      const need = (10 - target.health); // higher need when low health
      const groupSkillValue = (target.skill === "Medic" ? 3 : (target.skill === "Hunter" ? 3 : (target.skill === "Navigator" ? 2 : 2)));

      // Community-minded voters weight need and group value
      if (voter.selfish === 0) {
        score += need * 1.2;
        score += groupSkillValue * 1.0;
      }
      // Mixed voters balance
      if (voter.selfish === 1) {
        score += need * 0.7;
        score += groupSkillValue * 1.1;
      }
      // Selfish voters prioritize allies + power dynamics
      if (voter.selfish === 2) {
        score += groupSkillValue * 0.8;
        score += (target.health >= 7 ? 1.0 : 0); // prefer strength
        score -= need * 0.3; // less likely to help vulnerable
      }

      // Alliance bias
      if (voter.allyIdLastRound === target.id) score += 3 + voter.allianceNeed;

      // Reciprocity
      if (voter.helpedLastRoundBy === target.id) score += 2;

      // Selfish voters avoid empowering very strong competitors (unless allied)
      if (voter.selfish === 2 && target.health >= 9 && voter.allyIdLastRound !== target.id) score -= 1.5;

      // If target is voter themself: selfish voters often self-vote
      if (target.id === voter.id) score += (voter.selfish === 2 ? 2.5 : 0.2);

      // Build a simple reason string (used in log)
      const reasonParts = [];
      if (voter.allyIdLastRound === target.id) reasonParts.push("alliance");
      if (target.health <= 4) reasonParts.push("low health");
      if (target.skill === "Medic") reasonParts.push("medic");
      if (target.skill === "Hunter") reasonParts.push("food/water skill");
      if (!reasonParts.length) reasonParts.push("best odds");
      const reason = `I voted ${target.name} because ${reasonParts.join(", ")}.`;

      return { score, reason };
    }

    // Apply your pick + NPC votes to decide water recipient (majority including you)
    function resolveWaterRecipient(playerPickId, npcVotesArr){
      const tally = new Map();
      for (const c of state.chars) tally.set(c.id, 0);

      // Your vote counts as 1
      tally.set(playerPickId, (tally.get(playerPickId) || 0) + 1);

      // NPC votes
      for (const v of npcVotesArr) {
        tally.set(v.targetId, (tally.get(v.targetId) || 0) + 1);
      }

      let max = -1e9, winners = [];
      for (const [id, n] of tally.entries()) {
        if (n > max) { max = n; winners = [id]; }
        else if (n === max) winners.push(id);
      }
      const winnerId = winners[randInt(0, winners.length-1)];
      return { winnerId, tally, max, tied: winners.length > 1, winners };
    }

    // Update Community/Selfish scores based on fairness + alliances
    function updateMeters(winnerId, npcVotesArr){
      const winner = state.chars.find(c=>c.id===winnerId);
      const player = state.chars.find(c=>c.isPlayer);

      // "Need-based" choice increases community; "power-based" choice increases selfish
      const need = 10 - winner.health;

      // Community-minded choice heuristic: low health or Medic/Hunter = community
      const communityLean = (winner.health <= 4 ? 2 : 0) + (winner.skill === "Medic" ? 2 : 0) + (winner.skill === "Hunter" ? 1 : 0);
      const selfishLean = (winner.health >= 8 ? 2 : 0) + (winner.selfish === 2 ? 1 : 0);

      // Shift scores slightly each round
      state.community = clamp(state.community + (communityLean >= selfishLean ? 1 : 0), 0, 10);
      state.selfish   = clamp(state.selfish   + (selfishLean > communityLean ? 1 : 0), 0, 10);

      // Betrayal: if an NPC has an ally but voted against them, increase selfish
      for (const v of npcVotesArr) {
        const voter = state.chars.find(c=>c.id===v.voterId);
        if (!voter) continue;
        if (voter.allyIdLastRound && voter.allyIdLastRound !== v.targetId) {
          state.selfish = clamp(state.selfish + 1, 0, 10);
          logLine(`<span class="small bad">Betrayal:</span> ${escapeHtml(voter.name)} didn’t vote with their ally.`);
        }
      }

      // Global effect: if community > selfish, small heal; if selfish > community, small damage
      if (state.community > state.selfish) {
        for (const c of state.chars) c.health = clamp(c.health + 1, 0, 10);
        logLine(`<span class="good">Group Effect:</span> Community dominates → everyone gains +1 Health.`);
      } else if (state.selfish > state.community) {
        for (const c of state.chars) c.health = clamp(c.health - 1, 0, 10);
        logLine(`<span class="bad">Group Effect:</span> Selfish dominates → everyone loses -1 Health.`);
      } else {
        logLine(`<span class="muted">Group Effect:</span> Scores tied → no global change.`);
      }

      // Track who helped whom (for reciprocity next round): winner "helped" everyone who voted for them
      for (const v of npcVotesArr) {
        const voter = state.chars.find(c=>c.id===v.voterId);
        if (voter && v.targetId === winnerId) voter.helpedLastRoundBy = winnerId;
      }
      // If you voted for winner, you consider them as helping you (can affect their alliance with you indirectly)
      if (playerPickId === winnerId) player.helpedLastRoundBy = winnerId;
    }

    // Suggest pick for player (simple heuristic)
    function suggestPick(){
      // Prefer lowest health among active, with tie-breaker for Medic/Hunter
      const active = state.chars.filter(c => state.round >= c.collapsedUntilRound);
      active.sort((a,b) => {
        const aScore = (a.health) + (a.skill === "Medic" ? -1 : 0) + (a.skill === "Hunter" ? -0.5 : 0);
        const bScore = (b.health) + (b.skill === "Medic" ? -1 : 0) + (b.skill === "Hunter" ? -0.5 : 0);
        return aScore - bScore;
      });
      return active[0]?.id || state.chars[0]?.id;
    }

    // ----------------------------
    // Round Runner
    // ----------------------------
    let playerPickId = null;

    function runRoundStart(){
      // advance round
      state.round += 1;
      state.pendingPickId = null;
      playerPickId = null;

      logLine(`<span class="name">— Round ${state.round} begins —</span>`);

      // health tick
      applyHealthTick();
      logLine(`<span class="muted">Health tick applied (based on Independence).</span>`);

      // compute alliances
      const alliances = computeAlliances();
      if (alliances.length) {
        const pretty = alliances.map(([a,b]) => `${state.chars.find(c=>c.id===a).name} ↔ ${state.chars.find(c=>c.id===b).name}`).join(", ");
        logLine(`<span class="warn">Alliances formed:</span> ${escapeHtml(pretty)}`);
      } else {
        logLine(`<span class="muted">No alliances formed this round.</span>`);
      }

      // dialogue in captain-influenced order
      logLine(`<span class="muted">Discussion (Speaker Captain influences order):</span>`);
      npcDialogue();

      // enable player pick
      state.pendingPickId = $("waterPick").value;
      $("confirmPickBtn").disabled = false;

      render();
    }

    function confirmPick(){
      if (!state.pendingPickId) return;
      playerPickId = state.pendingPickId;

      const picked = state.chars.find(c=>c.id===playerPickId);
      logLine(`<span class="name">${escapeHtml(picked.name)}</span> was chosen by <span class="tag">You</span> to receive <b>Water</b>.`);

      // NPC votes
      const votes = npcVotes();
      // Log a few vote reasons to keep it minimal
      const sample = votes.slice(0, 3);
      for (const v of sample) {
        const voter = state.chars.find(c=>c.id===v.voterId);
        logLine(`<span class="small muted">${escapeHtml(voter.name)}:</span> ${escapeHtml(v.reason)}`);
      }
      if (votes.length > sample.length) {
        logLine(`<span class="small muted">(+${votes.length - sample.length} more NPC votes)</span>`);
      }

      // Resolve winner
      const result = resolveWaterRecipient(playerPickId, votes);
      const winner = state.chars.find(c=>c.id===result.winnerId);

      // Apply consequence: winner becomes next round’s Speaker Captain
      state.speakerCaptainId = winner.id;

      // Announce tally (compact)
      const tallyStr = Array.from(result.tally.entries())
        .map(([id,n]) => `${state.chars.find(c=>c.id===id).name}:${n}`)
        .sort((a,b)=> {
          const na = parseInt(a.split(":").pop(),10);
          const nb = parseInt(b.split(":").pop(),10);
          return nb - na;
        })
        .join(" · ");

      logLine(`<b>Water recipient (group vote):</b> <span class="name">${escapeHtml(winner.name)}</span> ${result.tied ? `<span class="small warn">(tie-break)</span>` : ""}`);
      logLine(`<span class="small muted">Tally:</span> <span class="small">${escapeHtml(tallyStr)}</span>`);
      logLine(`<b>Consequence:</b> ${escapeHtml(winner.name)} becomes <span class="tag">Speaker Captain</span> next round (controls speaking order).`);

      // Update meters + global effects
      updateMeters(result.winnerId, votes);

      // Check game over
      const over = isGameOver();
      if (over.over) {
        logLine(`<span class="bad"><b>Game Over:</b></span> ${escapeHtml(over.reason)}`);
        $("nextRoundBtn").disabled = true;
      } else if (state.round >= state.maxRounds) {
        logLine(`<span class="good"><b>End:</b></span> You survived ${state.maxRounds} rounds. Review patterns in who gained voice and resources.`);
        $("nextRoundBtn").disabled = true;
      }

      // clear pending
      state.pendingPickId = null;
      playerPickId = null;
      $("confirmPickBtn").disabled = true;

      render();
    }

    // ----------------------------
    // Game Setup / Reset
    // ----------------------------
    function setupNewGame(){
      state.started = true;
      state.round = 0;
      state.maxRounds = 8;
      state.community = 6;
      state.selfish = 4;
      state.speakerCaptainId = null;
      state.pendingPickId = null;
      playerPickId = null;

      // create player + 4 NPCs (minimal)
      const used = new Set();
      function uniqueName(){
        let n;
        do { n = pick(NAMES); } while (used.has(n));
        used.add(n);
        return n;
      }

      state.chars = [
        newChar({name: "You", isPlayer: true}),
        newChar({name: uniqueName()}),
        newChar({name: uniqueName()}),
        newChar({name: uniqueName()}),
        newChar({name: uniqueName()}),
      ];

      clearLog();
      logLine(`<span class="name">New Game</span> — You are stranded with 4 NPCs. No one is eliminated; power shifts through voice.`);
      logLine(`<span class="muted">Click “Run Next Round” to begin.</span>`);

      $("nextRoundBtn").disabled = false;
      $("confirmPickBtn").disabled = true;

      render();
    }

    function resetAll(){
      state.started = false;
      state.round = 0;
      state.community = 0;
      state.selfish = 0;
      state.speakerCaptainId = null;
      state.chars = [];
      state.pendingPickId = null;
      playerPickId = null;

      clearLog();
      render();
    }

    // ----------------------------
    // Wiring
    // ----------------------------
    $("newGameBtn").onclick = setupNewGame;

    $("nextRoundBtn").onclick = () => {
      const over = isGameOver();
      if (over.over) return;
      if (!state.started) return;
      if (state.round >= state.maxRounds) return;
      runRoundStart();
    };

    $("waterPick").addEventListener("change", () => {
      state.pendingPickId = $("waterPick").value;
      $("confirmPickBtn").disabled = !state.started || state.round === 0 || !state.pendingPickId;
    });

    $("confirmPickBtn").onclick = confirmPick;

    $("autoPickBtn").onclick = () => {
      if (!state.started || state.round === 0) return;
      const id = suggestPick();
      if (!id) return;
      $("waterPick").value = id;
      state.pendingPickId = id;
      $("confirmPickBtn").disabled = false;
      const c = state.chars.find(x=>x.id===id);
      logLine(`<span class="muted small">Suggestion:</span> Consider giving Water to <b>${escapeHtml(c.name)}</b> (lowest need/skill heuristic).`);
    };

    $("resetBtn").onclick = resetAll;

    // initial
    resetAll();
  </script>
</body>
</html>
